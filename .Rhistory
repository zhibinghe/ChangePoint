devtool::documents()
devtools::documents()
devtools::document()
l = 1200
h = seq(150,by=150,length.out=6)
jump = rep(0,7)
beta1 = c(2,-1,2.5,-3,-0.2,2.5)/50
beta1 = c(beta1,-sum(beta1*(c(h[1],diff(h))))/(l-tail(h,1)))
signal = gen.signal(l,h,jump,beta1)
noise = rnorm(length(signal),0,1)
gamma = 25
sdata = smth.gau(signal+noise,gamma)
ddy = diff(sdata,differences=2)
est.sigma2(ddy,gamma,0.5)
est.sigma2()
est.sigma2
3/(8*sqrt(pi)*gamma^5)
est.sigma2(ddy,gamma,1)
est.sigma2(ddy,gamma,0.8)
est.sigma2(ddy,gamma,0.4)
est.sigma2(ddy,gamma,0.2)
est.sigma2(ddy,gamma,0.05)
est.sigma2(ddy,gamma,1)
est.sigma2(ddy,gamma,2)
est.sigma2 = function(x,gamma,k=0.5){
lmax = which.peaks(x); lmin = which.peaks(x,decreasing=T)
J = c(x[lmax],-x[lmin])
ind = c(lmax,lmin)[J>= mean(J)+k*sd(J)]
delete = function(y){
v=vector()
for(i in 1:length(y)){
v1 = (y[i]-4*gamma) : (y[i]+4*gamma)
v = append(v,v1)
}
intersect(1:length(x),unique(v))
}
var2d = var(x[-delete(ind)])
return(1/(2*sqrt(pi)*(3/(8*sqrt(pi)*var2d))^(1/5)))
}
est.sigma2(ddy,gamma)
1/(2*sqrt(pi)*gamma)
noise = rnorm(length(signal),0,2)
gamma = 25
sdata = smth.gau(signal+noise,gamma)
ddy = diff(sdata,differences=2)
est.sigma2(ddy,gamma)
?rnorm
1/(2*sqrt(pi)*sqrt(gamma^2+4))
Fdr = function(uh,th,b){
confband = function(th,b) unique(unlist(lapply(th,function(x){seq(ceiling(x-b),floor(x+b))})))
if (length(uh)==0) {
FDR = 0
Power = 0}
else{
n.tp = sum(uh %in% confband(th,b))
FDR = 1 - n.tp/length(uh)
Power = min(n.tp/length(th),1)
}
data.frame(matrix(c(FDR,Power),nrow=1,dimnames=list(NULL,c("FDR","Power"))))
}
Fdr(uh=c(7,15,32,47),th=c(10,20,30,40,50),b=4)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
Fdr = function(uh,th,b){
confband = function(th,b) unique(unlist(lapply(th,function(x){seq(ceiling(x-b),floor(x+b))})))
if (length(uh)==0) {
FDR = 0
Power = 0}
else{
n.tp = sum(uh %in% confband(th,b))
FDR = 1 - n.tp/length(uh)
Power = min(n.tp/length(th),1)
}
return(data.frame(matrix(c(FDR,Power),nrow=1,dimnames=list(NULL,c("FDR","Power")))))
}
Fdr(uh=c(7,15,32,47),th=c(10,20,30,40,50),b=4)
devtools::document()
devtools::document()
source('~/Documents/R/dSTEM/R/main.R')
devtools::document()
signal = gen.signal(l,h,jump,beta1)
l = 1200
h = seq(150,by=150,length.out=6)
jump = rep(0,7)
beta1 = c(2,-1,2.5,-3,-0.2,2.5)/50
beta1 = c(beta1,-sum(beta1*(c(h[1],diff(h))))/(l-tail(h,1)))
signal = gen.signal(l,h,jump,beta1)
l = 1200
h = seq(150,by=150,length.out=6)
jump = rep(0,7)
beta1 = c(2,-1,2.5,-3,-0.2,2.5)/50
beta1 = c(beta1,-sum(beta1*(c(h[1],diff(h))))/(l-tail(h,1)))
signal = gen.signal(l,h,jump,beta1)
# Gaussian kernel
.kern = function(x,v=1){
temp = exp(-x^2/(2*v^2))
return(temp/sum(temp))
}
#' Simulate different types of signal
#'
#' @param l length of data, if data is periodic then the length of period
#' @param h numerical vector of change-point locations
#' @param jump vector of jump values at change-point locations
#' @param b1 vector of piecewise slopes
#' @param rep number of periods if data is periodic
#' @param shift vector of vertical shifts for each period
#'
#' @return a vector of simulated signal
#' @examples
#' l = 1200
#' h = seq(150,by=150,length.out=6)
#' jump = rep(0,7)
#' beta1 = c(2,-1,2.5,-3,-0.2,2.5)/50
#' beta1 = c(beta1,-sum(beta1*(c(h[1],diff(h))))/(l-tail(h,1)))
#' signal = gen.signal(l,h,jump,beta1)
gen.signal = function(l,h,jump,b1,rep,shift){
if(missing(rep)) rep = 1
if(missing(shift)) shift = 0
if(length(rep)!=length(shift)) stop("rep and shift should have the same length")
if(h[length(h)] > l) stop("h should not be greater than l")
if(length(jump)!=length(b1) | length(jump)!= length(h)+1)
stop("Length of jump or b1 is not matched with the length of h")
f = function(b0){
s = vector();t = 1:l
for(i in 1:(length(h)+1)){
nn = ifelse(i==1,h[i],ifelse(i==(length(h)+1),l-h[i-1],h[i]-h[i-1]))
start = ifelse(i==1,1,h[i-1]+1)
end = ifelse(i==(length(h)+1),l,h[i])
temp = rep(b0[i],nn) + rep(b1[i],nn)*t[start:end]
s = append(s,temp)
}
return(s)
}
b0 = cumsum(c(jump[1],-diff(b1)*h+jump[-1]))
return(rep(f(b0),rep)+rep(shift,each=l))
}
l = 1200
h = seq(150,by=150,length.out=6)
jump = rep(0,7)
beta1 = c(2,-1,2.5,-3,-0.2,2.5)/50
beta1 = c(beta1,-sum(beta1*(c(h[1],diff(h))))/(l-tail(h,1)))
signal = gen.signal(l,h,jump,beta1)
signal
devtools::document()
devtools::document()
devtools::document()
smth.gau(rnorm(1000),20)
devtools::document()
library(dSTEM)
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
devtools::document()
x=NULL
missing(x)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
l = 1200
h = seq(150,by=150,length.out=6)
jump = c(0,1.5,2,2.2,1.8,2,1.5)*3
beta1 = c(2,-1,2.5,-3,-0.2,2.5,-0.5)/50
signal = gen.signal(l=l,h=h,jump=jump,b1=beta1)
noise = rnorm(length(signal),0,1)
gamma = 25
sdata = smth.gau(signal+noise,gamma)
dy = diff(sdata)
ddy = diff(sdata,differences=2)
model2 = cpTest(x=ddy,order=2,gamma=gamma,alpha=0.1)
#' signal = gen.signal(l=l,h=h,jump=jump,b1=beta1)
#' noise = rnorm(length(signal),0,1)
#' gamma = 25
#' sdata = smth.gau(signal+noise,gamma)
#' dy = diff(sdata)
#' ddy = diff(sdata,differences=2)
#' model2 = cpTest(x=ddy,order=2,gamma=gamma,alpha=0.1)
##' breaks = est.pair(vall=model2$vall,peak=model2$peak,gamma=gamma)$cp
##' slope = est.slope(x=data,breaks=breaks)
##' model1 = cpTest(x=dy,order=1,alpha=0.05,gamma=gamma,breaks=breaks,slope=slope)
cpTest = function(x,order,alpha,gamma,sigma,breaks,slope,untest,nu,is.constant,margin){
if(!order %in% c(1,2))
stop("Please specify 1 or 2 for the first or second derivative respectively")
if(missing(gamma)) stop("gamma is required")
if(missing(untest)) untest = NULL
if(missing(is.constant)) is.constant = FALSE
#if(missing(sigma) && missing(nu)) stop("sigma is required")
if(missing(nu)) nu = 0
if(missing(sigma)){
sigma = ifelse(order==1,sqrt(1/(4*(sqrt(gamma^2+nu^2))^3*sqrt(pi))),sqrt(3/(8*(sqrt(gamma^2+nu^2))^5*sqrt(pi))))}
else{
sigma = ifelse(order==1,sqrt(1/(4*sqrt(pi)*(1/(2*sqrt(pi)*sigma))^3)),
sqrt(3/(8*sqrt(pi)*(1/(2*sqrt(pi)*sigma))^5)))}
if(missing(margin)) margin = length(x)
kappa = ifelse(order==1,3/sqrt(5),15/sqrt(105))
len = length(x)
margins = unlist(lapply((0:(len %/% margin))*margin, function(t)(t-ceiling(1.5*gamma)):(t+ceiling(1.5*gamma))))
untests = unique(unlist(lapply(untest, function(t)(t-ceiling(1.5*gamma)):(t+ceiling(1.5*gamma)))))
# peak height distribution
f1 = function(x) sqrt(3-kappa^2)/(sigma*sqrt(3))*dnorm(sqrt(3)*x/(sigma*sqrt(3-kappa^2)))+
sqrt(2*pi)*kappa*x/(sigma^2*sqrt(3))*dnorm(x/sigma)*pnorm(kappa*x/(sigma*sqrt(3-kappa^2)))
# minus slope
f2 = function(locind){
ty = vector()
for(i in 1:length(slope)){
if(i==1) seg = locind[locind<breaks[i]]
else if(i==length(slope)) seg = locind[locind>=breaks[i-1]]
else seg = locind[locind<breaks[i] & locind>=breaks[i-1]]
ty = append(ty,x[seg]-slope[i])
}
return(ty)
}
#standardize: improve the accuracy of numerically computing p-value
x = x/sigma
# local extreme
lmax = which.peaks(x)
lmin = which.peaks(x,decreasing=T)
if(order==1){
if(is.constant) Ty = c(x[lmax],-x[lmin])
else{
if(missing(breaks) | missing(slope))
stop("breaks and slope are required")
if(length(breaks)+1 != length(slope))
stop("breaks and slope should be matched")
slope = slope/sigma  #standardize
Ty = c(f2(lmax),-f2(lmin))
}
}
else{
lmax = setdiff(lmax,untests)
lmin = setdiff(lmin,untests)
Ty = c(x[lmax],-x[lmin])
}
# multiple testing
sigma = 1 #standardize
pval = unlist(lapply(Ty,function(x) integrate(f1,lower=x,upper=Inf)$value))
pthresh = fdrBH(pval,alpha)
if(pthresh==0){
peak = vall = NULL; pthresh = 0
warning("threshold for p-value is 0",call.=FALSE)
}
else{
peak = intersect(c(lmax,lmin)[which(pval<=pthresh)],lmax)
vall = intersect(c(lmax,lmin)[which(pval<=pthresh)],lmin)
peak = peak[!(peak %in% margins)] # delete the margin points
vall = vall[!(vall %in% margins)]
}
return(list(peak=peak,vall=vall,thresh=pthresh))
}
breaks = est.pair(vall=model2$vall,peak=model2$peak,gamma=gamma)$cp
breaks
devtools::document()
source('~/Documents/R/dSTEM/R/main.R')
source('~/Documents/R/dSTEM/R/main.R')
devtools::document()
est.pair = function(vall,peak,gamma){
fun = function(x,y){
l1 = x-2.5*gamma
l2 = x-1.5*gamma
r1 = x+1.5*gamma
r2 = x+2.5*gamma
t = y[which((y>=l1&y<=l2) | (y>=r1&y<=r2))]
if(length(t)==0) t = NA
if(length(t)>1) t = t[which.min(abs(abs(t-x)-2*gamma))]
return(t)
}
pair = sapply(vall,fun,y=peak)
sigle = setdiff(peak,pair)
pairs = as.data.frame(rbind(c(vall,sigle),c(pair,rep(NA,length(sigle)))))
return(list(pair=pairs,cp=sort(as.integer(as.vector(colMeans(pairs,na.rm=TRUE))))))
}
l = 1200
h = seq(150,by=150,length.out=6)
jump = c(0,1.5,2,2.2,1.8,2,1.5)*3
beta1 = c(2,-1,2.5,-3,-0.2,2.5,-0.5)/50
signal = gen.signal(l=l,h=h,jump=jump,b1=beta1)
noise = rnorm(length(signal),0,1)
gamma = 25
sdata = smth.gau(signal+noise,gamma)
dy = diff(sdata)
ddy = diff(sdata,differences=2)
model2 = cpTest(x=ddy,order=2,gamma=gamma,alpha=0.1)
breaks = est.pair(vall=model2$vall,peak=model2$peak,gamma=gamma)$cp
model2
breaks
l = 1200
h = seq(150,by=150,length.out=6)
jump = c(0,1.5,2,2.2,1.8,2,1.5)*3
beta1 = c(2,-1,2.5,-3,-0.2,2.5,-0.5)/50
signal = gen.signal(l=l,h=h,jump=jump,b1=beta1)
noise = rnorm(length(signal),0,1)
gamma = 25
sdata = smth.gau(signal+noise,gamma)
dy = diff(sdata)
ddy = diff(sdata,differences=2)
model2 = cpTest(x=ddy,order=2,gamma=gamma,alpha=0.1)
breaks = est.pair(vall=model2$vall,peak=model2$peak,gamma=gamma)$cp
slope = est.slope(x=data,breaks=breaks)
breaks
data
devtools::document()
devtools::document()
devtools::document()
library(dSTEM)
help(package="dSTEM")
devtools::document()
library(dSTEM)
help(package="dSTEM")
library(dSTEM)
library(dSTEM)
